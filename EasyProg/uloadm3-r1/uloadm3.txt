ULoad Model 3
-------------

ULoad is a loader system I developed for my Ultima gold cracks. This is a
cleaned up version of the loader I developed for Ultima 3 Gold, which is a
relatively basic 2-bit timed IRQ file loader. It also allows you to save
files, although it's limited to overwriting existing files and cannot create
new files. It supports a wide range of IEC drives, of course works on both PAL
and NTSC, and also supports SuperCPU and DTV2 running in turbo mode.


Supported Hardware
------------------

  * C64 and C128 (in C64 mode)
  * PAL and NTSC machines
  * The following drives:
    o 1541 (and compatible clones like Oceanic 118N and Excelerator+)
    o 1570
    o 1571 (both single and double sided mode)
    o 1581
    o CMD FD
    o CMD HD
  * SuperCPU
  * DTV/DTV2 (though it's known to be unstable for some users)


Usage
-----

The loader is provided as ca65 source code, which assembles to a library. The
code is split into four parts:

  * Initialization code: detects what hardware is available, and loads the
    appropriate driver.
  * Common drive code: loader code that is sent over to the drive.
  * Drivers: drive specific support code
  * Loader: the code for opening, reading, and writing files

To use the loader, link your project with uloadm3.lib, and call loader_init
during startup. Make sure that you don't bank out the kernal or disable the
system IRQ before initializing - it needs the kernal routines to load the
drivers. loader_init returns carry clear if everything is ok, and carry set if
initialization failed. It also prints a human readable status message at the
bottom of the screen, detailing the detected hardware. After initialization,
everything except the loader can be overwritten.

After initialization, you call loader_open to read or write files. Reading is
done by calling loader_open with A set to $01, and the starting track and
sector in X and Y. If opening is successful, carry is clear, and you can read
data a byte at a time by calling loader_read. A set carry signals end of file.

To write a file, you call loader_open with A set to $02, track and sector in
X/Y, and status is returned in the carry flag. After opening, the first two
bytes (the load address) have to be read with loader_read. After that you
write a byte at a time with loader_write until it returns with the carry set.

To read the directory, you call loader_open with A set to $24 ("$"). The
driver automatically selects the correct track and sector for the directory.
Reading works the same as normal files.

Notes:

  * The loader treats all files as PRG files.

  * You have to finish reading or writing a file before you try to open
    another.

  * Saving is limited to overwriting files. You can not create new files, or
    change the size of an existing file.

  * When writing a file the first two bytes (the load address) should be read,
    and the rest of the bytes written.

  * The timing critical portion of the send and receive routines use SEI/CLI
    to avoid being interrupted by IRQs. As a result, your IRQ handler might be
    delayed by up to two raster lines. To compensate, set raster IRQs to
    trigger two lines earlier than needed, and go down to the correct line
    with cmp $d012 or a second IRQ. If you need a stable IRQ I recommend using
    raster synchronized CIA timers, e.g. using Hermit Soft's routines on
    codebase.

  * The timing critical portion of the send and receive routines fail if
    they're interrupted by DMA. They check for badlines and automatically
    delay to avoid them, but you have to handle sprite DMA yourself. Wrap it
    inside an IRQ to disable the loader while the sprites are enabled, and
    make sure you don't exit before DMA is over. Also don't forget that
    sprites at the bottom also display underneath the top border.


Configuring
-----------

If memory is tight, or you just don't need all of the functionality, you can
disable a few of the features in the loader Makefile:

  * UL3_SAVE            Enables file writing
  * UL3_SUPERCPUFIX     Enables SuperCPU support
  * UL3_DTV2FIX         Enables DTV2 support

With everything enabled, the memory resident loader is 375 bytes, and with
everything disabled it's 268 bytes.

The loader relies heavily on the ld65 linker configuration. To begin with, the
drive code needs a few symbols:

  SYMBOLS {
    DCOMN_START:	value = $0300;
    DCOMN_SIZE:		value = $00cb;
    DBUFR_START:	value = $0600;
    DBUFR_SIZE:		value = $0100;
    DSPEC_START:	value = DCOMN_START + DCOMN_SIZE;
    DSPEC_SIZE:		value = DBUFR_START - DSPEC_START;
  }

If you modify the drive code, you have to adjust the DCOMN_SIZE symbol to
match the size of the common drive code.

The loader needs the following memory areas defined:

  MEMORY {
    DRIVECODE: start = somewhere nice, size = big enough;
    LOADER: start = somewhere out of the way, size = $0177;

    DRIVECOMMON: start = DCOMN_START, size = DCOMN_SIZE;
    DRIVESPECIFIC: start = DSPEC_START, size = DSPEC_SIZE, define = yes;
    DRIVE1541: start = DSPEC_START, size = DSPEC_SIZE;
    DRIVE1571: start = DSPEC_START, size = DSPEC_SIZE;
    DRIVE1581: start = DSPEC_START, size = DSPEC_SIZE;
    DRIVECMDHD: start = DSPEC_START, size = DSPEC_SIZE;
    DRIVECMDFD: start = DSPEC_START, size = DSPEC_SIZE;
    DRIVEBUFFER: start = DBUFR_START, size = DBUFR_SIZE;
  }

and the following segments:

  SEGMENTS {
    LOADER: load = LOADER, type = rw;

    DRIVECOMMON: load = DRIVECODE, run = DRIVECOMMON, type = rw, define = yes,
      align = $0100;
    DRIVE1541:   load = DRIVECODE, run = DRIVE1541, type = rw, define = yes;
    DRIVE1571:   load = DRIVECODE, run = DRIVE1571, type = rw, define = yes;
    DRIVE1581:   load = DRIVECODE, run = DRIVE1581, type = rw, define = yes;
    DRIVECMDHD:  load = DRIVECODE, run = DRIVECMDHD, type = rw, define = yes;
    DRIVECMDFD:  load = DRIVECODE, run = DRIVECMDFD, type = rw, define = yes;
    DRIVEBUFFER: load = DRIVEBUFFER, type = bss, align = $0100;
  }

The initialization code also uses the normal code, data, rodata, and bss
segments.


Sample Code
-----------

	jsr loader_init		; initialize loader
	bcs error		; carry set on error
	
	lda #$7f		; disable CIA irqs
	sta $dc0d
	
	jsr scan_files		; read directory and store tracks/sectors
				; for a sample implementation, see test/test.s
	
	ldx #0			; load file 0
	ldy file_sector,x
	lda file_track,x
	tax
	lda #1
	jsr loader_open
	bcs error
	
	jsr loader_read		; read the load address
	bcs error
	sta load_ptr
	jsr loader_read
	bcs error
	sta load_ptr + 1
	ldy #0
@read:
	jsr loader_read		; read data into memory
	bcs @read_eof
	sta (load_ptr),y
	iny
	bne @read
	inc load_ptr + 1
	bne @read
@read_eof:

	ldx #0			; write file 0 back to disk
	ldy file_sector,x
	lda file_track,x
	tax
	lda #1
	jsr loader_open
	bcs error
	
	jsr loader_read		; read the load address
	bcs error
	sta load_ptr
	jsr loader_read
	bcs error
	sta load_ptr + 1
	ldy #0
@write:
	lda (load_ptr),y	; write data to disk
	jsr loader_write
	bcs @write_eof
	iny
	bne @write
	inc load_ptr + 1
	bne @write
@write_eof:
	

Credits
-------

The code has its roots in loaders done by Lasse Öörni, Marko Mäkelä, and
K.M/TABOO.

The drive detection code is from Dreamload by Doc Bacardi and Ninja of the
Dreams.

Thanks goes to Krill, Fungus, and Daniel Kahlin who helped improve the loader
in various ways.

The rest was done by me, Per Olofsson, MagerValp@gmail.com.